<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>å€‹åˆ¥Navigation</title>

  <!-- PWA (manifest) -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0b1020">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0f1730;
      --text:#e9eefc;
      --muted:#a8b2d6;
      --line:rgba(255,255,255,.10);
      --accent:#6ea8ff;
      --good:#48d597;
      --danger:#ff6b6b;
      --warn:#ffcc66;
      --r:16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background: radial-gradient(1200px 700px at 10% 0%, rgba(110,168,255,.22), transparent 60%),
                  radial-gradient(900px 600px at 90% 0%, rgba(72,213,151,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:50;
      padding:10px 12px 12px;
      background: linear-gradient(to bottom, rgba(11,16,32,.95), rgba(11,16,32,.70));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .row{ display:flex; gap:10px; align-items:center; }
    .title{ font-weight:800; letter-spacing:.03em; font-size:16px; margin:0 0 8px; opacity:.95; }
    .inputGrid{ display:grid; grid-template-columns: 1fr; gap:8px; }
    .field{
      display:flex; gap:8px; align-items:center;
      padding:10px;
      background: rgba(18,26,51,.85);
      border:1px solid var(--line);
      border-radius: var(--r);
    }
    .field input{
      width:100%;
      border:0; outline:none;
      background: transparent;
      color: var(--text);
      font-size:16px;
    }
    .field input::placeholder{ color: rgba(233,238,252,.45); }

    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      display:inline-flex; gap:8px; align-items:center; justify-content:center;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: rgba(110,168,255,.18); border-color: rgba(110,168,255,.35); }
    .btn.good{ background: rgba(72,213,151,.16); border-color: rgba(72,213,151,.35); }
    .btn.danger{ background: rgba(255,107,107,.12); border-color: rgba(255,107,107,.3); }
    .btn.warn{ background: rgba(255,204,102,.12); border-color: rgba(255,204,102,.3); }
    .btn.small{ padding:8px 10px; font-size:13px; }
    .btn.icon{ width:42px; padding:10px 0; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .status{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .pill{
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.05);
    }
    .pill.warn{
      border-color: rgba(255,204,102,.35);
      background: rgba(255,204,102,.10);
      color: rgba(255,235,190,.95);
    }

    #mapWrap{ padding:12px; }
    #map{
      height: 46vh;
      min-height: 320px;
      border-radius: calc(var(--r) + 6px);
      border:1px solid var(--line);
      overflow:hidden;
      box-shadow: 0 16px 50px rgba(0,0,0,.35);
    }

    main{ padding-bottom: 18px; }
    .panel{
      margin: 0 12px 12px;
      padding: 12px;
      border-radius: calc(var(--r) + 6px);
      border:1px solid var(--line);
      background: rgba(18,26,51,.60);
      backdrop-filter: blur(8px);
    }
    .listHeader{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom: 10px;
    }
    .listHeader .meta{ color:var(--muted); font-size:12px; }
    .list{
      display:flex; flex-direction:column; gap:10px;
      max-height: 38vh;
      overflow:auto;
      padding-right: 4px;
    }
    .card{
      border:1px solid var(--line);
      background: rgba(15,23,48,.68);
      border-radius: var(--r);
      padding: 10px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
    }
    /* å®Œäº†ï¼šã‚„ã•ã—ã„ã‚°ãƒªãƒ¼ãƒ³ï¼ˆãŠã™ã™ã‚ï¼‰ */
.card.done{
  opacity: 1;
  filter: none;
  background: rgba(72,213,151,.15);
  border-color: rgba(72,213,151,.35);
}


    .toast{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      z-index: 9999;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.12);
      color: var(--text);
      font-size: 13px;
      display:none;
      max-width: min(92vw, 540px);
      text-align:center;
      backdrop-filter: blur(8px);
      white-space: pre-wrap;
    }

    .adjustBar{
      position: fixed;
      left: 12px; right: 12px; bottom: 12px;
      z-index: 9998;
      display:none;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px;
      border-radius: calc(var(--r) + 6px);
      border:1px solid var(--line);
      background: rgba(18,26,51,.78);
      backdrop-filter: blur(10px);
      box-shadow: 0 16px 50px rgba(0,0,0,.35);
    }
    .adjustBar .msg{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <header>
    <div class="title">å€‹åˆ¥Navigation</div>

    <div class="inputGrid">
      <!-- éƒµä¾¿ç•ªå· â†’ ä½æ‰€è£œå®Œ -->
      <div class="field">
        <input id="zip" type="tel" inputmode="numeric" pattern="[0-9\-]*"
               placeholder="éƒµä¾¿ç•ªå·ï¼ˆä¾‹ï¼š5200806ï¼‰" autocomplete="postal-code">
        <button class="btn small" id="zipBtn">ã€’ ä½æ‰€è£œå®Œ</button>
      </div>

      <div class="field">
        <button class="btn icon" id="micName" title="éŸ³å£°å…¥åŠ›ï¼ˆåç§°ï¼‰">ğŸ¤</button>
        <input id="name" type="text" placeholder="åå‰" autocomplete="off">
      </div>

      <div class="field">
        <button class="btn icon" id="micAddr" title="éŸ³å£°å…¥åŠ›ï¼ˆä½æ‰€ï¼‰">ğŸ¤</button>
        <input id="addr" type="text" placeholder="ä½æ‰€" autocomplete="off">
      </div>

      <div class="row" style="justify-content:space-between;">
        <button class="btn primary" id="addBtn">ï¼‹ ç™»éŒ²</button>
        <div class="row">
          <button class="btn small" id="locBtn">ğŸ“ ç¾åœ¨åœ°</button>
          <button class="btn small danger" id="clearBtn">ğŸ—‘ å…¨æ¶ˆå»</button>
        </div>
      </div>

      <div class="status">
        <div class="pill" id="countPill">ä»¶æ•°ï¼š0</div>
        <div class="pill" id="speechPill">éŸ³å£°ï¼šæœªç¢ºèª</div>
        <div class="pill" id="geoPill">ä½ç½®æƒ…å ±ï¼šæœªç¢ºèª</div>
        <div class="pill" id="netPill">APIï¼šæœªç¢ºèª</div>
        <div class="pill" id="gpsPill">GPSï¼šæœªç›£è¦–</div>
        <div class="pill" id="hdgPill">æ–¹ä½ï¼šâ€”</div>
      </div>
    </div>
  </header>

  <main>
    <div id="mapWrap">
      <div id="map"></div>
    </div>

    <section class="panel">
      <div class="listHeader">
        <div>
          <div style="font-weight:900;">ç›®çš„åœ°ãƒªã‚¹ãƒˆ</div>
          <div class="meta">æœªå®Œäº†ãƒ«ãƒ¼ãƒˆç·š / âœ¨è¿‘ã„é †ï¼ˆç¾åœ¨åœ°èµ·ç‚¹ï¼‰</div>
        </div>
        <div class="row">
          <button class="btn small" id="optBtn">âœ¨ è¿‘ã„é †</button>
          <button class="btn small" id="fitBtn">ğŸ§­ å…¨ä½“è¡¨ç¤º</button>
        </div>
      </div>

      <div class="list" id="list"></div>

      <div class="hint">
        â€» ä½æ‰€â†’åº§æ¨™ã¯ <b>/api/geocode</b>ï¼ˆVercelçµŒç”±ï¼‰ã§ã™ã€‚<br>
        â€» å¸‚è¡—åœ°ã®ã‚ºãƒ¬ã¯ <b>ğŸ“èª¿æ•´â†’âœ…ç¢ºå®š</b> ã§å…¥å£ã‚’è¨˜æ†¶ã§ãã¾ã™ã€‚<br>
        â€» ãƒˆãƒ³ãƒãƒ«ç­‰ã§GPSãŒæ­¢ã¾ã£ãŸã‚‰ <b>GPSï¼šãƒ­ã‚¹ãƒˆ</b> ãŒå‡ºã¾ã™ï¼ˆçŸ­æ™‚é–“ã¯æ¨æ¸¬ä½ç½®ã‚’è¡¨ç¤ºï¼‰ã€‚
      </div>
    </section>
  </main>

  <div class="toast" id="toast"></div>

  <div class="adjustBar" id="adjustBar">
    <div class="msg" id="adjustMsg">ãƒ”ãƒ³ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆã¾ãŸã¯ã‚¿ãƒƒãƒ—/é•·æŠ¼ã—ï¼‰ã§ä½ç½®ã‚’èª¿æ•´ â†’ ç¢ºå®š</div>
    <div class="row" style="gap:8px;">
      <button class="btn small" id="cancelAdjustBtn">â†© ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="btn small good" id="confirmAdjustBtn">âœ… ç¢ºå®š</button>
    </div>
  </div>

<script>
(() => {
  // ========= Utilities =========
  const $ = (id) => document.getElementById(id);
  const toastEl = $("toast");
  let toastTimer = null;
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.style.display = "block";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.style.display = "none", 2600);
  }
  function esc(s){ return (s ?? "").toString().replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // ========= State =========
  const STORAGE_KEY = "koguchi_delivery_stops_v4";
  const GEO_CACHE_KEY = "koguchi_geo_cache_v1";
  const PIN_MEMORY_KEY = "koguchi_pin_memory_v1";

  const ADD_COOLDOWN_MS = 900;
  let lastAddAt = 0;

  /** @type {{id:string,name:string,address:string,lat:number,lng:number,status:"pending"|"done",createdAt:number}[]} */
  let stops = [];

  // route visuals
  let routeLine = null;      // æœªå®Œäº†ãƒ«ãƒ¼ãƒˆç·šï¼ˆç›´ç·šï¼‰
  let predictMarker = null;  // æ¨æ¸¬ä½ç½®
  let routePtsCache = [];    // ãƒ«ãƒ¼ãƒˆç·šã®åº§æ¨™é…åˆ—ï¼ˆã‚¹ãƒŠãƒƒãƒ—ç”¨ï¼‰

  // GPS watch / loss detect
  let watchId = null;
  let lastFixAt = 0;
  let gpsLost = false;
  let lostNotified = false;

  // Recommended thresholds
  const GPS_LOST_MS = 12_000;     // 12ç§’æ›´æ–°ãªã—ã§ãƒ­ã‚¹ãƒˆ
  const PREDICT_MAX_MS = 90_000;  // æ¨æ¸¬ã¯æœ€å¤§90ç§’
  const SNAP_ROUTE_M = 55;        // ãƒ«ãƒ¼ãƒˆç·šã«55mä»¥å†…ãªã‚‰ã‚¹ãƒŠãƒƒãƒ—
  const PREDICT_STEP_MS = 1000;   // æ¨æ¸¬æ›´æ–°é–“éš”

  // current location / motion
  let currentMarker = null;
  let currentLatLng = null;
  let lastSpeedMps = null;  // pos.coords.speed (m/s)
  let headingDeg = null;    // ã‚³ãƒ³ãƒ‘ã‚¹æ–¹ä½ï¼ˆ0=Nï¼‰
  let lastHeadingAt = 0;
  let predictTimer = null;
  let lostStartedAt = 0;
  let lostBase = null;      // {lat,lng, t, speed, heading}
  const hdgPill = $("hdgPill");

  // adjust mode
  let adjustingId = null;
  let adjustMarker = null;
  let adjustLatLng = null;

  const adjustBar = $("adjustBar");
  const adjustMsg = $("adjustMsg");

  // ========= Address normalization =========
  function normalizeAddress(a){
    return (a || "")
      .replace(/[â€-â€“â€”âˆ’]/g, "-")
      .replace(/[ ã€€]+/g, " ")
      .replace(/(ã€’\s*\d{3}-?\d{4})/g, "")
      .replace(/(å·å®¤|å®¤|éš|F).*/g, "")
      .trim();
  }
  function stripBuilding(a){
    return (a || "")
      .replace(/(ãƒ“ãƒ«|ãƒãƒ³ã‚·ãƒ§ãƒ³|ãƒã‚¤ãƒ„|ã‚³ãƒ¼ãƒ|ã‚¢ãƒ‘ãƒ¼ãƒˆ|ã‚¿ãƒ¯ãƒ¼|ãƒ¡ã‚¾ãƒ³|ãƒ¬ã‚¸ãƒ‡ãƒ³ã‚¹|ãƒã‚¦ã‚¹|ã‚³ãƒ¼ãƒˆ).*/g, "")
      .trim();
  }
  function memKey(address){
    return normalizeAddress(address).toLowerCase();
  }

  // ========= Pin memory =========
  function loadPinMemory(address){
    const k = memKey(address);
    if(!k) return null;
    try{
      const mem = JSON.parse(localStorage.getItem(PIN_MEMORY_KEY) || "{}");
      return mem[k] || null;
    }catch(e){ return null; }
  }
  function savePinMemory(address, lat, lng){
    const k = memKey(address);
    if(!k) return;
    const mem = JSON.parse(localStorage.getItem(PIN_MEMORY_KEY) || "{}");
    mem[k] = { lat, lng, updatedAt: Date.now() };
    localStorage.setItem(PIN_MEMORY_KEY, JSON.stringify(mem));
  }

  // ========= Geo cache =========
  function loadGeoCache(){
    try{ return JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || "{}") || {}; }
    catch(e){ return {}; }
  }
  function saveGeoCache(cache){
    localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache));
  }
  function cacheKey(addr){
    return (addr || "").toString().trim().toLowerCase();
  }

  // ========= Persistence =========
  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw) stops = JSON.parse(raw) || [];
    }catch(e){ stops = []; }
  }
  function save(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(stops));
  }

  // ========= Map =========
  const map = L.map("map", { zoomControl: false }).setView([35.02, 135.86], 12);
  L.control.zoom({ position: "bottomright" }).addTo(map);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap"
  }).addTo(map);

  const markersLayer = L.layerGroup().addTo(map);

  // tap/long press: move adjust marker
  map.on("click", (e) => {
    if(!adjustingId || !adjustMarker) return;
    adjustMarker.setLatLng(e.latlng);
    adjustLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
  });
  map.on("contextmenu", (e) => {
    if(!adjustingId || !adjustMarker) return;
    adjustMarker.setLatLng(e.latlng);
    adjustLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
  });

  // ========= Distance helpers =========
  function distanceMeters(a, b){
    const R = 6371000;
    const toRad = (d) => d * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const x = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(x));
  }

  // ========= Simple route snapping (â‘£ä»£æ›¿) =========
  // lat/lngã‚’è¿‘ä¼¼å¹³é¢ã«ã—ã¦æœ€è¿‘ç‚¹ã‚’æ±‚ã‚ã‚‹ï¼ˆçŸ­è·é›¢ç”¨ï¼‰
  function snapToRouteIfNear(pos){
    if(!routePtsCache || routePtsCache.length < 2) return pos;

    // ãƒ«ãƒ¼ãƒˆç·šã®æœ€è¿‘ç‚¹ï¼ˆç·šåˆ†ï¼‰ã‚’æ¢ã™
    const lat0 = pos.lat * Math.PI/180;
    const kx = 111320 * Math.cos(lat0); // deg->m approx
    const ky = 110540;

    const px = pos.lng * kx;
    const py = pos.lat * ky;

    let best = null;
    let bestD2 = Infinity;

    for(let i=0;i<routePtsCache.length-1;i++){
      const a = routePtsCache[i];
      const b = routePtsCache[i+1];

      const ax = a.lng * kx, ay = a.lat * ky;
      const bx = b.lng * kx, by = b.lat * ky;

      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;

      const vv = vx*vx + vy*vy;
      let t = vv ? (wx*vx + wy*vy)/vv : 0;
      t = Math.max(0, Math.min(1, t));

      const cx = ax + t*vx;
      const cy = ay + t*vy;

      const dx = px - cx, dy = py - cy;
      const d2 = dx*dx + dy*dy;

      if(d2 < bestD2){
        bestD2 = d2;
        best = { x: cx, y: cy, kx, ky };
      }
    }

    if(!best) return pos;
    const d = Math.sqrt(bestD2); // meters
    if(d > SNAP_ROUTE_M) return pos;

    // snapped point back to lat/lng
    return { lat: best.y / best.ky, lng: best.x / best.kx, snapped: true };
  }

  // ========= Adjust mode =========
  function startAdjust(id){
    const s = stops.find(x => x.id === id);
    if(!s) return;

    adjustingId = id;
    adjustLatLng = { lat: s.lat, lng: s.lng };

    if(adjustMarker){
      map.removeLayer(adjustMarker);
      adjustMarker = null;
    }

    adjustMarker = L.marker([s.lat, s.lng], { draggable: true })
      .addTo(map)
      .bindPopup("ğŸ“ èª¿æ•´ä¸­ï¼ˆãƒ‰ãƒ©ãƒƒã‚° / ã‚¿ãƒƒãƒ— / é•·æŠ¼ã—ï¼‰")
      .openPopup();

    adjustMarker.on("dragend", () => {
      const p = adjustMarker.getLatLng();
      adjustLatLng = { lat: p.lat, lng: p.lng };
    });

    map.setView([s.lat, s.lng], Math.max(map.getZoom(), 17), { animate:true });
    adjustBar.style.display = "flex";
    adjustMsg.textContent = "ãƒ”ãƒ³ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆã¾ãŸã¯ã‚¿ãƒƒãƒ—/é•·æŠ¼ã—ï¼‰ã§ç§»å‹• â†’ âœ…ç¢ºå®š";
    toast("èª¿æ•´ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚Šã¾ã—ãŸ");
  }

  function cancelAdjust(silent=false){
    adjustingId = null;
    adjustLatLng = null;
    if(adjustMarker){
      map.removeLayer(adjustMarker);
      adjustMarker = null;
    }
    adjustBar.style.display = "none";
    if(!silent) toast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
  }

  function confirmAdjust(){
    if(!adjustingId || !adjustLatLng){ cancelAdjust(); return; }
    const s = stops.find(x => x.id === adjustingId);
    if(!s){ cancelAdjust(); return; }

    s.lat = adjustLatLng.lat;
    s.lng = adjustLatLng.lng;
    save();
    savePinMemory(s.address, s.lat, s.lng);

    redrawMarkers();
    renderList();

    map.setView([s.lat, s.lng], Math.max(map.getZoom(), 17), { animate:true });
    toast("ç¢ºå®šã—ã¾ã—ãŸ âœ…");
    cancelAdjust(true);
  }

  // ========= QR(URL params) -> inputs =========
  function applyQueryToInputs(){
    try{
      const u = new URL(location.href);
      const qName = u.searchParams.get("name") || "";
      const qAddr = u.searchParams.get("addr") || u.searchParams.get("address") || "";
      if(!qName && !qAddr) return;

      if(qName) $("name").value = qName;
      if(qAddr) $("addr").value = qAddr;
      toast("QRã‹ã‚‰å…¥åŠ›ã—ã¾ã—ãŸï¼ˆç™»éŒ²ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰");

      u.search = "";
      history.replaceState({}, "", u.toString());
      $("addr").focus();
    }catch(e){ console.warn(e); }
  }

  // ========= Zip -> address =========
  async function fetchAddressByZip(zipRaw){
    const zip = (zipRaw || "").replace(/[^\d]/g, "");
    if(zip.length !== 7) throw new Error("éƒµä¾¿ç•ªå·ã¯7æ¡ã§å…¥åŠ›ã—ã¦ãã ã•ã„");
    const url = `https://zipcloud.ibsnet.co.jp/api/search?zipcode=${zip}`;
    const res = await fetch(url);
    const j = await res.json();
    if(j.status !== 200 || !j.results || !j.results[0]){
      throw new Error("éƒµä¾¿ç•ªå·ã‹ã‚‰ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }
    const r = j.results[0];
    return `${r.address1}${r.address2}${r.address3}`;
  }

  // ========= Geocoding via Vercel API =========
  async function geocodeAddress(address){
    const url = new URL("/api/geocode", location.origin);
    url.searchParams.set("q", address);
    const res = await fetch(url.toString(), { headers: { "Accept":"application/json" } });
    if(!res.ok) throw new Error(`APIã‚¨ãƒ©ãƒ¼(${res.status})`);
    const j = await res.json();
    if(!j.ok || !j.found) return null;
    return { lat: j.lat, lng: j.lng, display: j.display };
  }

  async function geocodeWithFallback(rawAddress){
    const cache = loadGeoCache();
    const a1 = normalizeAddress(rawAddress);
    if(a1){
      const k = cacheKey(a1);
      if(cache[k]) return cache[k];
    }
    let geo = null;
    if(a1) geo = await geocodeAddress(a1);
    if(!geo){
      const a2 = stripBuilding(a1);
      if(a2 && a2 !== a1){
        const k2 = cacheKey(a2);
        if(cache[k2]) return cache[k2];
        geo = await geocodeAddress(a2);
      }
    }
    if(geo){
      const k = cacheKey(a1);
      cache[k] = geo;
      saveGeoCache(cache);
    }
    return geo;
  }

  // ========= Render =========
  function updatePills(){
    $("countPill").textContent = `ä»¶æ•°ï¼š${stops.length}`;
  }

  function iconForStop(index, status){
    const n = index + 1;
    const bg = status === "done" ? "rgba(255,255,255,.18)" : "rgba(110,168,255,.28)";
    const bd = status === "done" ? "rgba(255,255,255,.22)" : "rgba(110,168,255,.55)";
    const color = "rgba(233,238,252,.95)";
    return L.divIcon({
      className: "",
      html: `
        <div style="
          width:34px;height:34px;border-radius:999px;
          display:grid;place-items:center;
          background:${bg};
          border:1px solid ${bd};
          color:${color};
          font-weight:900;
          box-shadow:0 10px 30px rgba(0,0,0,.35);
          backdrop-filter: blur(6px);
        ">${n}</div>
      `,
      iconSize: [34,34],
      iconAnchor: [17,34]
    });
  }

  function drawRouteLine(){
    // æœªå®Œäº†ã ã‘
    const pts = stops.filter(s => s.status === "pending").map(s => [s.lat, s.lng]);

    // cache for snapping (as objects)
    routePtsCache = stops.filter(s => s.status === "pending").map(s => ({ lat: s.lat, lng: s.lng }));

    if(routeLine){
      map.removeLayer(routeLine);
      routeLine = null;
    }
    if(pts.length < 2) return;

    routeLine = L.polyline(pts, { weight: 4, opacity: 0.9 }).addTo(map);
  }

  function redrawMarkers(){
    markersLayer.clearLayers();
    stops.forEach((s, i) => {
      L.marker([s.lat, s.lng], { icon: iconForStop(i, s.status) })
        .addTo(markersLayer)
        .bindPopup(`<b>${esc(s.name || "ï¼ˆåç§°ãªã—ï¼‰")}</b><br>${esc(s.address)}`);
    });
    drawRouteLine();
  }

  function renderList(){
    const list = $("list");
    list.innerHTML = "";

    const pending = stops.filter(s => s.status === "pending");
    const done = stops.filter(s => s.status === "done");
    const ordered = [...pending, ...done];

    ordered.forEach((s) => {
      const idx = stops.findIndex(x => x.id === s.id);
      const card = document.createElement("div");
      card.className = "card" + (s.status === "done" ? " done" : "");
      card.innerHTML = `
        <div>
          <div class="name"><span class="num">${idx+1}</span>${esc(s.name || "ï¼ˆåç§°ãªã—ï¼‰")}</div>
          <div class="addr">${esc(s.address)}</div>
        </div>
        <div class="actions">
          <button class="btn small primary" data-action="nav" data-id="${esc(s.id)}">â–¶ ãƒŠãƒ“</button>
          <button class="btn small good" data-action="done" data-id="${esc(s.id)}">âœ” å®Œäº†</button>
          <button class="btn small" data-action="focus" data-id="${esc(s.id)}">ğŸ—º åœ°å›³</button>
          <button class="btn small" data-action="adjust" data-id="${esc(s.id)}">ğŸ“ èª¿æ•´</button>
        </div>
      `;
      list.appendChild(card);
    });

    updatePills();
  }

  function focusStop(id){
    const s = stops.find(x => x.id === id);
    if(!s) return;
    map.setView([s.lat, s.lng], Math.max(map.getZoom(), 16), { animate:true });
  }

  function fitAll(){
    const pending = stops.filter(s => s.status === "pending");
    if(pending.length === 0){
      toast(stops.length ? "æœªå®Œäº†ãŒã‚ã‚Šã¾ã›ã‚“" : "ç›®çš„åœ°ãŒã‚ã‚Šã¾ã›ã‚“");
      return;
    }
    const latlngs = pending.map(s => [s.lat, s.lng]);
    map.fitBounds(L.latLngBounds(latlngs).pad(0.22));
  }

  // ========= Optimize order (A: current location start) =========
  function dist2(a, b){
    const dx = a.lat - b.lat;
    const dy = a.lng - b.lng;
    return dx*dx + dy*dy;
  }

  function optimizeOrder(){
    const pending = stops.filter(s => s.status === "pending");
    const done = stops.filter(s => s.status === "done");
    if(pending.length <= 2){ toast("æœ€é©åŒ–ã™ã‚‹ä»¶æ•°ãŒå°‘ãªã„ã§ã™"); return; }

    const start = currentLatLng
      ? { lat: currentLatLng.lat, lng: currentLatLng.lng }
      : { lat: pending[0].lat, lng: pending[0].lng };

    const remaining = pending.slice();
    const ordered = [];
    let cur = start;

    while(remaining.length){
      let bestIdx = 0, bestD = Infinity;
      for(let i=0;i<remaining.length;i++){
        const d = dist2(cur, remaining[i]);
        if(d < bestD){ bestD = d; bestIdx = i; }
      }
      const next = remaining.splice(bestIdx, 1)[0];
      ordered.push(next);
      cur = { lat: next.lat, lng: next.lng };
    }

    stops = [...ordered, ...done];
    save();
    redrawMarkers();
    renderList();
    toast(currentLatLng ? "ç¾åœ¨åœ°ã‹ã‚‰è¿‘ã„é †ã«ä¸¦ã¹æ›¿ãˆã¾ã—ãŸ" : "è¿‘ã„é †ã«ä¸¦ã¹æ›¿ãˆã¾ã—ãŸ");
  }

  // ========= Actions =========
  async function addStop(){
    const now = Date.now();
    if(now - lastAddAt < ADD_COOLDOWN_MS){ toast("é€£ç¶šè¿½åŠ ã¯å°‘ã—å¾…ã£ã¦ã­"); return; }
    lastAddAt = now;

    const name = $("name").value.trim();
    const addressRaw = $("addr").value.trim();
    if(!addressRaw){ toast("ä½æ‰€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); $("addr").focus(); return; }

    $("addBtn").disabled = true;
    $("addBtn").textContent = "â€¦åº§æ¨™åŒ–ä¸­";

    try{
      const remembered = loadPinMemory(addressRaw);

      let lat, lng;
      if(remembered){
        lat = Number(remembered.lat);
        lng = Number(remembered.lng);
        toast("ä¿å­˜æ¸ˆã¿ã®å…¥å£ä½ç½®ã‚’ä½¿ç”¨ã—ã¾ã—ãŸ");
      }else{
        const geo = await geocodeWithFallback(addressRaw);
        if(!geo){
          toast("ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\nãƒ»çœŒå¸‚ã‹ã‚‰å…¥ã‚Œã‚‹\nãƒ»å»ºç‰©å/éƒ¨å±‹ç•ªå·ã‚’å¤–ã™\nã‚’è©¦ã—ã¦ãã ã•ã„");
          return;
        }
        lat = geo.lat; lng = geo.lng;
      }

      const id = crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2);

      stops.push({
        id,
        name: name || "",
        address: addressRaw,
        lat, lng,
        status: "pending",
        createdAt: Date.now()
      });

      save();
      redrawMarkers();
      renderList();

      map.setView([lat, lng], 16, { animate:true });

      $("name").value = "";
      $("addr").value = "";
      $("zip").value = "";
      $("name").focus();

      if(!remembered) toast("è¿½åŠ ã—ã¾ã—ãŸ");
    }catch(e){
      console.error(e);
      toast(`åº§æ¨™åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n${e?.message || "é€šä¿¡/è¨­å®šã‚’ç¢ºèª"}`);
    }finally{
      $("addBtn").disabled = false;
      $("addBtn").textContent = "ï¼‹ ç™»éŒ²";
    }
  }

  function setDone(id){
    const s = stops.find(x => x.id === id);
    if(!s) return;
    s.status = (s.status === "done") ? "pending" : "done";
    save();
    redrawMarkers();
    renderList();
  }

  function openNav(id){
    const s = stops.find(x => x.id === id);
    if(!s) return;

    const base = new URL("https://www.google.com/maps/dir/");
    if(currentLatLng){
      base.pathname = `/maps/dir/${currentLatLng.lat},${currentLatLng.lng}/${s.lat},${s.lng}/`;
    }else{
      base.pathname = "/maps/search/";
      base.searchParams.set("api", "1");
      base.searchParams.set("query", `${s.lat},${s.lng}`);
    }
    window.open(base.toString(), "_blank");
  }

  function clearAll(){
    if(!confirm("å…¨ã¦ã®è¡Œå…ˆã‚’æ¶ˆå»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
    stops = [];
    save();
    redrawMarkers();
    renderList();
    toast("å…¨æ¶ˆå»ã—ã¾ã—ãŸï¼ˆå…¥å£è¨˜æ†¶ã¯æ®‹ã‚Šã¾ã™ï¼‰");
  }

  // ========= GPS watch + loss detection (â‘¡) =========
  function setGpsPill(text, isWarn=false){
    const el = $("gpsPill");
    el.textContent = text;
    el.classList.toggle("warn", !!isWarn);
  }

  function updateHeadingPill(){
    if(headingDeg == null){
      hdgPill.textContent = "æ–¹ä½ï¼šâ€”";
      return;
    }
    const d = Math.round(headingDeg);
    hdgPill.textContent = `æ–¹ä½ï¼š${d}Â°`;
  }

  function startWatch(){
    if(!navigator.geolocation){
      $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šéå¯¾å¿œ";
      setGpsPill("GPSï¼šéå¯¾å¿œ", true);
      toast("ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“");
      return;
    }

    if(watchId){
      // already watching
      toast("GPSç›£è¦–ä¸­ã§ã™");
      return;
    }

    setGpsPill("GPSï¼šç›£è¦–é–‹å§‹â€¦");
    $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šç›£è¦–ä¸­â€¦";

    watchId = navigator.geolocation.watchPosition(onPos, onPosErr, {
      enableHighAccuracy: true,
      timeout: 12000,
      maximumAge: 2000
    });

    // loss monitor tick
    if(!predictTimer){
      predictTimer = setInterval(checkGpsLossAndPredict, PREDICT_STEP_MS);
    }
  }

  function stopWatch(){
    if(watchId){
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
    if(predictTimer){
      clearInterval(predictTimer);
      predictTimer = null;
    }
    setGpsPill("GPSï¼šåœæ­¢");
    $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šæœªå–å¾—";
  }

  function onPos(pos){
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;
    lastFixAt = Date.now();

    // speed (m/s) sometimes null
    if(typeof pos.coords.speed === "number" && !Number.isNaN(pos.coords.speed)){
      lastSpeedMps = pos.coords.speed;
    }

    // â‘£ï¼šãƒ«ãƒ¼ãƒˆç·šãŒè¿‘ã‘ã‚Œã°ã‚¹ãƒŠãƒƒãƒ—ï¼ˆå¸‚è¡—åœ°ã®é£›ã³ã‚’æŠ‘ãˆã‚‹ï¼‰
    const raw = { lat, lng };
    const snapped = snapToRouteIfNear(raw);

    currentLatLng = { lat: snapped.lat, lng: snapped.lng };

    if(currentMarker){
      currentMarker.setLatLng([currentLatLng.lat, currentLatLng.lng]);
    }else{
      currentMarker = L.circleMarker([currentLatLng.lat, currentLatLng.lng], {
        radius: 8, weight: 2, opacity: 1, fillOpacity: .35
      }).addTo(map).bindPopup("ç¾åœ¨åœ°");
    }

    // GPSå¾©å¸°å‡¦ç†
    if(gpsLost){
      gpsLost = false;
      lostNotified = false;
      setGpsPill("GPSï¼šå¾©å¸°");
      toast("GPSãŒå¾©å¸°ã—ã¾ã—ãŸ");
      if(navigator.vibrate) navigator.vibrate([80, 60, 80]);
      hidePredictMarker();
    }else{
      setGpsPill("GPSï¼šOK");
    }

    $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šOK";
  }

  function onPosErr(err){
    console.warn(err);
    $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šNG";
    setGpsPill("GPSï¼šNG", true);
    toast("ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ï¼ˆè¨±å¯/é›»æ³¢/çœé›»åŠ›è¨­å®šã‚’ç¢ºèªï¼‰");
  }

  function checkGpsLossAndPredict(){
    if(!watchId) return;

    const now = Date.now();
    const dt = now - lastFixAt;

    if(lastFixAt === 0){
      setGpsPill("GPSï¼šç›£è¦–ä¸­â€¦");
      return;
    }

    // ãƒ­ã‚¹ãƒˆåˆ¤å®š
    if(dt >= GPS_LOST_MS){
      if(!gpsLost){
        gpsLost = true;
        lostStartedAt = now;
        lostBase = currentLatLng ? {
          lat: currentLatLng.lat,
          lng: currentLatLng.lng,
          t: now,
          speed: lastSpeedMps,
          heading: headingDeg
        } : null;

        setGpsPill("GPSï¼šãƒ­ã‚¹ãƒˆ", true);
        if(!lostNotified){
          lostNotified = true;
          toast("GPSãƒ­ã‚¹ãƒˆä¸­ï¼ˆãƒˆãƒ³ãƒãƒ«ç­‰ï¼‰ã€‚åœ°å›³/ç›®çš„åœ°ã¯è¡¨ç¤ºã•ã‚Œã¾ã™");
          if(navigator.vibrate) navigator.vibrate([180, 120, 180]);
        }
      }else{
        setGpsPill("GPSï¼šãƒ­ã‚¹ãƒˆ", true);
      }

      // â‘¢ æ¨æ¸¬ä½ç½®ï¼ˆé€Ÿåº¦+æ–¹ä½ãŒã‚ã‚‹å ´åˆã®ã¿ã€90ç§’ã¾ã§ï¼‰
      tryPredict(now);
      return;
    }

    // OKç¶™ç¶š
    if(!gpsLost){
      setGpsPill("GPSï¼šOK");
    }
  }

  function showPredictMarker(latlng){
    if(!predictMarker){
      predictMarker = L.circleMarker([latlng.lat, latlng.lng], {
        radius: 7,
        weight: 2,
        opacity: 0.9,
        fillOpacity: 0.12,
        dashArray: "6 6"
      }).addTo(map).bindPopup("æ¨æ¸¬ä½ç½®ï¼ˆGPSãƒ­ã‚¹ãƒˆä¸­ï¼‰");
    }else{
      predictMarker.setLatLng([latlng.lat, latlng.lng]);
    }
  }

  function hidePredictMarker(){
    if(predictMarker){
      map.removeLayer(predictMarker);
      predictMarker = null;
    }
  }

  function tryPredict(now){
    if(!lostBase) return;

    const elapsed = now - lostBase.t;
    if(elapsed <= 0) return;

    if(elapsed > PREDICT_MAX_MS){
      // æ¨æ¸¬æœŸé™çµ‚äº†
      hidePredictMarker();
      return;
    }

    const sp = lostBase.speed;
    const hdg = lostBase.heading;

    if(!(typeof sp === "number" && sp > 0.6 && typeof hdg === "number")){
      // é€Ÿåº¦/æ–¹ä½ãŒå–ã‚Œãªã„ãªã‚‰æ¨æ¸¬ã—ãªã„ï¼ˆèª¤å·®ãŒå¤§ãã„ã®ã§ï¼‰
      hidePredictMarker();
      return;
    }

    // ç›´ç·šæ¨æ¸¬ï¼šè·é›¢ = é€Ÿåº¦ * æ™‚é–“
    const dist = sp * (elapsed/1000);
    // ãŸã ã—éå¤§ã«ãªã‚Šã‚„ã™ã„ã®ã§ä¸Šé™
    const distCapped = Math.min(dist, 1200); // 1.2kmä¸Šé™

    // æ–¹ä½ï¼ˆ0=Nï¼‰ã‹ã‚‰ç§»å‹•å…ˆã‚’è¨ˆç®—ï¼ˆç°¡æ˜“ï¼‰
    const rad = hdg * Math.PI / 180;
    const dNorth = Math.cos(rad) * distCapped;
    const dEast  = Math.sin(rad) * distCapped;

    // meters -> degrees approx
    const lat = lostBase.lat + (dNorth / 110540);
    const lng = lostBase.lng + (dEast  / (111320 * Math.cos(lostBase.lat * Math.PI/180)));

    // â‘£ã®ä»£æ›¿ï¼šæ¨æ¸¬ç‚¹ã‚‚ãƒ«ãƒ¼ãƒˆç·šã«è¿‘ã‘ã‚Œã°ã‚¹ãƒŠãƒƒãƒ—
    const snapped = snapToRouteIfNear({ lat, lng });

    showPredictMarker(snapped);
  }

  // ========= Compass (â‘¡è£œåŠ©) =========
  function initCompass(){
    // iOSã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§è¨±å¯ãŒå¿…è¦ãªå ´åˆã‚ã‚Š
    const handler = (e) => {
      let h = null;
      // iOS: webkitCompassHeading (0=N)
      if(typeof e.webkitCompassHeading === "number"){
        h = e.webkitCompassHeading;
      }else if(typeof e.alpha === "number"){
        // alpha: 0..360 (device orientation). ç’°å¢ƒã«ã‚ˆã£ã¦åŒ—åŸºæº–ã§ãªã„ã“ã¨ã‚‚ã‚ã‚‹ã®ã§ã€Œè£œåŠ©ã€æ‰±ã„
        h = 360 - e.alpha;
      }
      if(h == null || Number.isNaN(h)) return;

      headingDeg = (h + 360) % 360;
      lastHeadingAt = Date.now();
      updateHeadingPill();
    };

    // è¨±å¯ãŒå¿…è¦ãªç’°å¢ƒï¼ˆä¸»ã«iOSï¼‰
    if(typeof DeviceOrientationEvent !== "undefined" &&
       typeof DeviceOrientationEvent.requestPermission === "function"){
      // è¨±å¯ã¯ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆã€å†…ã§å‘¼ã¶å¿…è¦ãŒã‚ã‚‹ã®ã§ã€ç¾åœ¨åœ°ãƒœã‚¿ãƒ³å†…ã§å‘¼ã¶
      window.__requestCompassPermission = async () => {
        try{
          const p = await DeviceOrientationEvent.requestPermission();
          if(p === "granted"){
            window.addEventListener("deviceorientation", handler, true);
            toast("æ–¹ä½ã‚»ãƒ³ã‚µãƒ¼ã‚’æœ‰åŠ¹åŒ–ã—ã¾ã—ãŸ");
          }else{
            toast("æ–¹ä½ã‚»ãƒ³ã‚µãƒ¼ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ");
          }
        }catch(e){
          console.warn(e);
          toast("æ–¹ä½ã‚»ãƒ³ã‚µãƒ¼ã®è¨±å¯ã«å¤±æ•—");
        }
      };
    }else{
      // Androidç­‰ï¼šãã®ã¾ã¾è³¼èª­
      window.addEventListener("deviceorientationabsolute", handler, true);
      window.addEventListener("deviceorientation", handler, true);
    }
  }

  // ========= Speech =========
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recog = null;
  function initSpeech(){
    if(!SpeechRecognition){ $("speechPill").textContent = "éŸ³å£°ï¼šéå¯¾å¿œ"; return; }
    $("speechPill").textContent = "éŸ³å£°ï¼šOK";
    recog = new SpeechRecognition();
    recog.lang = "ja-JP";
    recog.interimResults = false;
    recog.maxAlternatives = 1;
  }
  function speakToInput(inputEl){
    if(!recog){ toast("éŸ³å£°å…¥åŠ›ãŒä½¿ãˆã¾ã›ã‚“ï¼ˆChromeç³»æ¨å¥¨ï¼‰"); return; }
    try{ recog.abort(); }catch(e){}
    toast("è©±ã—ã¦ãã ã•ã„â€¦");
    recog.onresult = (ev) => {
      const text = ev.results[0][0].transcript || "";
      const cur = inputEl.value.trim();
      inputEl.value = cur ? (cur + " " + text) : text;
      toast("å…¥åŠ›ã—ã¾ã—ãŸ");
    };
    recog.onerror = () => toast("éŸ³å£°å…¥åŠ›ã«å¤±æ•—ï¼ˆæ¨©é™/HTTPSã‚’ç¢ºèªï¼‰");
    recog.start();
  }

  // ========= API health check =========
  async function apiCheck(){
    try{
      const url = new URL("/api/geocode", location.origin);
      url.searchParams.set("q", "æ»‹è³€çœŒå¤§æ´¥å¸‚æµœå¤§æ´¥");
      const res = await fetch(url.toString(), { headers: { "Accept":"application/json" } });
      if(!res.ok) throw new Error("NG");
      const j = await res.json();
      $("netPill").textContent = (j && j.ok) ? "APIï¼šOK" : "APIï¼šNG";
    }catch(e){
      $("netPill").textContent = "APIï¼šNG";
    }
  }

  // ========= PWA register (â‘ ) =========
  async function registerSW(){
    if(!("serviceWorker" in navigator)) return;
    try{
      await navigator.serviceWorker.register("/sw.js");
      // toast("ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œï¼ˆæœ€å°ï¼‰ã‚’æœ‰åŠ¹åŒ–ã—ã¾ã—ãŸ"); // é¬±é™¶ã—ã‘ã‚Œã°OFF
    }catch(e){
      console.warn("SW register failed", e);
    }
  }

  // ========= Event bindings =========
  $("addBtn").addEventListener("click", addStop);
  $("clearBtn").addEventListener("click", clearAll);
  $("fitBtn").addEventListener("click", fitAll);
  $("optBtn").addEventListener("click", optimizeOrder);

  $("cancelAdjustBtn").addEventListener("click", () => cancelAdjust(false));
  $("confirmAdjustBtn").addEventListener("click", confirmAdjust);

  $("name").addEventListener("keydown", (e) => { if(e.key === "Enter") $("addr").focus(); });
  $("addr").addEventListener("keydown", (e) => { if(e.key === "Enter") addStop(); });
  $("zip").addEventListener("keydown", (e) => { if(e.key === "Enter") $("zipBtn").click(); });

  $("zipBtn").addEventListener("click", async () => {
    const zip = $("zip").value.trim();
    if(!zip){ toast("éƒµä¾¿ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); $("zip").focus(); return; }
    $("zipBtn").disabled = true;
    try{
      const addr = await fetchAddressByZip(zip);
      const cur = $("addr").value.trim();
      $("addr").value = cur ? (addr + " " + cur) : addr;
      toast("ä½æ‰€ã‚’è£œå®Œã—ã¾ã—ãŸã€‚ç•ªåœ°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
      $("addr").focus();
    }catch(e){
      toast(e.message || "éƒµä¾¿ç•ªå·æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }finally{
      $("zipBtn").disabled = false;
    }
  });

  $("micName").addEventListener("click", () => speakToInput($("name")));
  $("micAddr").addEventListener("click", () => speakToInput($("addr")));

  $("list").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if(!btn) return;
    const id = btn.getAttribute("data-id");
    const action = btn.getAttribute("data-action");
    if(!id || !action) return;

    if(action === "nav") openNav(id);
    if(action === "done") setDone(id);
    if(action === "focus") focusStop(id);
    if(action === "adjust") startAdjust(id);
  });

  // ç¾åœ¨åœ°ãƒœã‚¿ãƒ³ï¼šGPSç›£è¦–ã‚’é–‹å§‹ï¼ˆãƒ­ã‚¹ãƒˆæ¤œçŸ¥ã®å‰æï¼‰
  $("locBtn").addEventListener("click", async () => {
    // iOSã‚³ãƒ³ãƒ‘ã‚¹è¨±å¯ï¼ˆå¿…è¦ãªå ´åˆã®ã¿ï¼‰
    if(typeof window.__requestCompassPermission === "function"){
      await window.__requestCompassPermission();
      window.__requestCompassPermission = null;
    }
    startWatch();
    // ç¾åœ¨åœ°ã¸å¯„ã›ã‚‹ï¼ˆåˆå›fixãŒæ¥ãŸã‚‰å‹æ‰‹ã«æ›´æ–°ã•ã‚Œã‚‹ï¼‰
    toast("GPSç›£è¦–ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆãƒˆãƒ³ãƒãƒ«ã§ãƒ­ã‚¹ãƒˆæ¤œçŸ¥ã—ã¾ã™ï¼‰");
  });

  // ========= Boot =========
  load();
  initSpeech();
  initCompass();
  redrawMarkers();
  renderList();

  if(SpeechRecognition) $("speechPill").textContent = "éŸ³å£°ï¼šOK";
  else $("speechPill").textContent = "éŸ³å£°ï¼šéå¯¾å¿œ";

  if(navigator.geolocation) $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šæœªå–å¾—";
  else $("geoPill").textContent = "ä½ç½®æƒ…å ±ï¼šéå¯¾å¿œ";

  setGpsPill("GPSï¼šæœªç›£è¦–");
  updateHeadingPill();

  apiCheck();
  applyQueryToInputs();
  registerSW();

})();
</script>
</body>
</html>


